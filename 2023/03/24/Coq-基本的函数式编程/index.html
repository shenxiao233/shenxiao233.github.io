<!DOCTYPE html><html lang="zh-CN"><head><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script defer src="/live2d-widget/autoload.js"></script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png"><link rel="icon" type="image/png" sizes="16x16" href="D:/images/logo2.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.example.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="coq基本语法笔记（一）"><meta property="og:type" content="article"><meta property="og:title" content="Coq Basics (I)"><meta property="og:url" content="http://www.example.com/2023/03/24/Coq-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/index.html"><meta property="og:site_name" content="致知苑"><meta property="og:description" content="coq基本语法笔记（一）"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-03-24T04:16:12.000Z"><meta property="article:modified_time" content="2023-03-30T00:20:33.115Z"><meta property="article:author" content="哂笑"><meta property="article:tag" content="coq"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://www.example.com/2023/03/24/Coq-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Coq Basics (I) | 致知苑</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/rss2.xml" title="致知苑" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><script src="https:shenxiao233.github.io/live2d/autoload.js"></script><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">致知苑</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/shenxiao233" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://www.example.com/2023/03/24/Coq-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="哂笑"><meta itemprop="description" content="输出倒逼思考"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="致知苑"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Coq Basics (I)</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-03-24 12:16:12" itemprop="dateCreated datePublished" datetime="2023-03-24T12:16:12+08:00">2023-03-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-30 08:20:33" itemprop="dateModified" datetime="2023-03-30T08:20:33+08:00">2023-03-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Coq/" itemprop="url" rel="index"><span itemprop="name">Coq</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span><div class="post-description">coq基本语法笔记（一）</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="inductive"><a href="#inductive" class="headerlink" title="inductive"></a>inductive</h2><p>Inductive是Coq用来定义数据类型，实际上Coq的数据类型十分精简，但是我们可以通过这样的方法来自定义数据类型，Coq中最基本的数据类型就是Type，相当于Java的Object。语句的结构为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inductive [TYPE_NAME] : [INHERITED_TYPE] := &#123;IND_DEF&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Inductive season : Type :=</span><br><span class="line">| spring</span><br><span class="line">| summer</span><br><span class="line">| autumn</span><br><span class="line">| winter.</span><br></pre></td></tr></table></figure><p>这个定义以关键字 Inductive 开头，说明是一个归纳定义，而紧跟其后的season : Type 声明 season 是我们新定义的一个类型。竖线隔开四种情况，spring、summer 等是类型构造子（type constructor），因为没带任何参数，可以简单理解为四个元素，它们组成一个集合，即名为 season 的类型所表示的集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Definition opposite_eason (s : season) : season :=</span><br><span class="line">match s with</span><br><span class="line">| spring =&gt; autumn</span><br><span class="line">| summer =&gt; winter</span><br><span class="line">| autumn =&gt; spring</span><br><span class="line">| winter =&gt; summer</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>定义一个名为 opposite_season 的函数，对输入的一个季节，返回与它相反的季节，因此输入和输出的类型均为 season，换句话说，这个函数自身的类型是 season → season。</p><p>在具体定义中我们以模式匹配（pattern matching）的方式，区分 s 的不同形式。如果 s 是 spring，则返回 autumn；如果是 summer，则返回 winter，等等。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Coq 中的每个表达式都有类型，它描述了该表达式所计算的东西的类别。 Check 指令会让 Coq 显示一个表达式的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Check true.</span><br><span class="line">(* ===&gt; true : bool *)</span><br></pre></td></tr></table></figure><p>如果在被 Check 的表达式后加上一个分号和你想验证的类型，那么 Coq 会 验证该表达式是否属于你提供的类型。当两者不一致时，Coq 会报错并终止执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Check true</span><br><span class="line">    : bool.</span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inductive bool : Type :=</span><br><span class="line">| true</span><br><span class="line">| false.</span><br></pre></td></tr></table></figure><p>布尔类型实际上是一个特殊的枚举类型，它只包含两个数据值，在这里我们不妨称为 true 和 false。</p><p>对布尔类型数据的常用操作如“与”、“或”、“非”等都容易定义。例如，我们定义函数 andb 来表示“与”操作。这个函数输入两个参数 b1 和 b2，如果b1 的值为 true，直接返回 b2 的值，否则返回 false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Definition andb (b1 : bool) (b2 : bool) : bool :=</span><br><span class="line">match b1 with</span><br><span class="line">| true =&gt; b2</span><br><span class="line">| false =&gt; false</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>上面这个函数的两个输入参数类型相同，在 Coq 中可以写得紧凑一点，依次列出两个参数，中间用空格隔开，最后写上类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Definition andb (b1 b2 : bool) : bool :=</span><br><span class="line">match b1 with</span><br><span class="line">| true =&gt; b2</span><br><span class="line">| false =&gt; false</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><h2 id="Notation-命令"><a href="#Notation-命令" class="headerlink" title="Notation 命令"></a>Notation 命令</h2><p>Notation 命令可以用来定义新的记号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notation &quot;x &amp;&amp; y&quot; := (andb x y).</span><br></pre></td></tr></table></figure><p>有个这个记号以后，将来如果我们写表达式 (b1 &amp;&amp; b2)，那么代表的意思就是 (andb b1 b2)，这类似有些编程语言中的宏定义。</p><h2 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h2><h3 id="simpl和reflexivity-化简"><a href="#simpl和reflexivity-化简" class="headerlink" title="simpl和reflexivity-化简"></a>simpl和reflexivity-化简</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Theorem plus_O_n: forall n : nat, o + n = n Proof. intros n. simpl. reflexitivity. Qed.</span><br></pre></td></tr></table></figure><p>这个证明只用了simpl和reflexivity两种方法。simpl可以将等式的两边同时化简(simplify)，而reflexivity是用来检查等式的两边是否完全一致(identical)。一般情况下，不需要加simpl，因为reflexivity本身在检查一致性的时候，就会自动的进行展开，如果需要在调试的时候查看化简之后的效果才会加上simpl。</p><p>reflexivity除了进行化简的工作，还会根据定义将产生式展开(unfolding)。化简和展开的区别在于，化简是将定义的函数（比如递归函数）化简到稳定的状态（对于递归函数，就是Base case）；展开则是利用产生式的构造子完整的写出数据的形式。</p><p>能够化简的一个前提条件是，函数能够无歧义的化简（上文中n + o &#x3D; n就不能够化简证明，需要分情况证明）。</p><h3 id="rewrite-重写"><a href="#rewrite-重写" class="headerlink" title="rewrite-重写"></a>rewrite-重写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Theorem plus_id_example : forall n m:nat,</span><br><span class="line">n = m -&gt; n + n = m + m. Proof. </span><br><span class="line">(* move both quantifiers into the context: *)</span><br><span class="line">intros n m. </span><br><span class="line">(* move the hypothesis into the context: *) </span><br><span class="line">intros H. </span><br><span class="line">(* rewrite the goal using the hypothesis: *)</span><br><span class="line">rewrite -&gt; H. reflexivity. Qed.</span><br></pre></td></tr></table></figure><p>重写(rewriting)指的是，在证明的过程中，按照给出的前提假设(Hypothesis)，在要证明的式子两边对变量进行改写，辅助证明。</p><p>-&gt;表示的意思是使用前提假设的右侧替换左侧，&lt;-表示左侧替换右侧。</p><p>对于上面的证明过程，我们无法指出所有可能的取值，因此证明的时候无法进行相应的确切的化简，因此需要改写变量满足假设进行证明，该重写过程就是n + n &#x3D; m + m (<em>–&gt;</em>) m + m &#x3D; m + m</p><h3 id="destruct"><a href="#destruct" class="headerlink" title="destruct"></a>destruct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Theorem surjective_pairing : forall (p : natprod), p = (fst p, snd p). </span><br><span class="line">Proof. intros p.</span><br><span class="line">destruct p as [n m]. </span><br><span class="line">simpl. reflexivity. Qed.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Theorem plus_1_neq_0 : </span><br><span class="line">forall n : nat, beq_nat (n + 1) 0 = false.</span><br><span class="line">Proof. intros n. </span><br><span class="line">destruct n as [| n&#x27;].</span><br><span class="line">- reflexivity. - reflexivity. Qed.</span><br></pre></td></tr></table></figure><p>上述代码可以改写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Theorem plus_1_neq_0&#x27; : </span><br><span class="line">forall n :nat, beq_nat (n + 1) 0 = false. </span><br><span class="line">Proof. intros [|n]. </span><br><span class="line">- reflexivity.</span><br><span class="line">- reflexivity. Qed.</span><br></pre></td></tr></table></figure><p>使用destruct对引入的参数进行分情况讨论，设置子目标(sub goal)，分别进行证明。分情况讨论允许多层的嵌套，在需要进行分情况讨论的地方进行destruct。</p><p>每个子目标前面的-没有语法含义，可以替换为+或者*。</p><p>destruct后面的中括号参数是根据类型的定义设置的，如果出现多种情况就是用|隔开。对于nat的定义，第一个构造子(constructor)并无参数，因此为空，第二个构造器的参数也是nat，因此需要指明参数名称。如果构造器都没有参数，那就可以省略as子句。</p><h3 id="induction-假设归纳"><a href="#induction-假设归纳" class="headerlink" title="induction-假设归纳"></a>induction-假设归纳</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Theorem plus_n_O : </span><br><span class="line">forall n:nat, n = n + 0. </span><br><span class="line">Proof. intros n. </span><br><span class="line">induction n as [| n&#x27; IHn&#x27;].</span><br><span class="line">- (* n = 0 *) reflexivity. </span><br><span class="line">- (* n = S n&#x27; *) simpl. rewrite &lt;- IHn&#x27;. </span><br><span class="line">reflexivity. Qed.</span><br></pre></td></tr></table></figure><p>那上述的证明来说明，n可以是任意大的自然数，如果按照分情况讨论的话，可能会一直化简下去，并不能验证任意大小的n。这种情况下，使用类似于数学归纳法进行证明，即induction，归纳证明命题的正确性。</p><p>归纳induction的语法结构同样类似与destruct，产生的不同的子目标，进行归纳证明。产生的子目标也同样根据参数的构造方法有关，并使用|区分不同构造子情况，并在之后子目标的论证用-、+或者*加以区别。induction可以提供关于子目标环境下的参数命名，也可以对子目标环境下的假设(hypothesis)进行命名（在上述论证中就是IHn’，代表着n’ &#x3D; n’ + 0），在该子目标下进行重写，进行进一步的论证。</p><h3 id="assert-行间证明"><a href="#assert-行间证明" class="headerlink" title="assert-行间证明"></a>assert-行间证明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Theorem mult_0_plus&#x27; : </span><br><span class="line">forall n m :nat, (0 + n) * m = n * m.</span><br><span class="line">Proof. intros n m. </span><br><span class="line">assert (H: 0 + n = n). &#123; reflexivity. &#125; </span><br><span class="line">rewrite → H. </span><br><span class="line">reflexivity. Qed.</span><br></pre></td></tr></table></figure><p>如果在证明的过程中需要加入临时的、显而易见的中间引理证明，那么可以考虑assert进行证明内的小引理证明(subtheorem)。assert这种方式引入了两个子目标，第一个便是断言(assertion)本身（在上述的论证中，断言被命名为H，指的是0+n&#x3D;0），这个子目标的论证囊括在大括号…中。另一个子目标就是在既有断言基础上进行原先的论证，通常也是通过重写来完成。</p><p>断言的方式主要是提供一种类似于匿名函数的功能。</p><h2 id="自然数类型"><a href="#自然数类型" class="headerlink" title="自然数类型"></a>自然数类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inductive nat : Type :=</span><br><span class="line">| O</span><br><span class="line">| S (n : nat).</span><br><span class="line">End Playground.</span><br></pre></td></tr></table></figure><p>O 表示自然数 0；S 表示后继函数，如果 n 是一个自然数，则 S n表示它的下一个自然数。</p><p>O, S O, S (S O), S (S (S O)), …对应通常的自然数 0, 1, 2, 3, ….。</p><p>例如，下面的 pred2 函数取比当且输入数 n 小 2 的数，除了特殊情况 n &#x3D; 0, 1，那时返回值为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Definition pred2 (n : nat) : nat :=</span><br><span class="line">match n with</span><br><span class="line">| O =&gt; O</span><br><span class="line">| S O =&gt; O</span><br><span class="line">| S (S n&#x27;) =&gt; n&#x27;</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><h2 id="Fixpoint"><a href="#Fixpoint" class="headerlink" title="Fixpoint"></a>Fixpoint</h2><p>Fixpoint允许递归的调用本身，但是这种调用必须是一种有界的。因此，Fixpoint函数中所匹配(match)的参数必须是以降序的方式进行展开，确保不会无限递归。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint plus (n : nat) (m : nat) : nat := </span><br><span class="line">match n with</span><br><span class="line">| O ⇒ m </span><br><span class="line">| S n&#x27; ⇒ S (plus n&#x27; m) end.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint beq_nat (n m : nat) : bool :=</span><br><span class="line">match n with</span><br><span class="line">| O ⇒ match m with </span><br><span class="line">| O ⇒ true </span><br><span class="line">| S m&#x27; ⇒ false end </span><br><span class="line">| S n&#x27; ⇒ match m with </span><br><span class="line">         | O ⇒ false </span><br><span class="line">         | S m&#x27; ⇒ beq_nat n&#x27; m&#x27; end end.</span><br></pre></td></tr></table></figure><p>为定义复杂一些的函数，仅用模式匹配还不够，我们需要递归定义，反映到语法层面就是定义的开头用关键字 Fixpoint 而不是 Definition。下面的函数 oddb 可判断当 n 取 0 或者 1 时，我们直接判断出结果，否则，n 是不是奇数这件事情依赖于 n 之前第二个数字的奇偶性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint oddb (n : nat) : bool :=</span><br><span class="line">match n with</span><br><span class="line">| O =&gt; false</span><br><span class="line">| S O =&gt; true</span><br><span class="line">| S (S n&#x27;) =&gt; oddb n&#x27;</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>如果一个函数的参数不止一个，那么用于模式匹配的参数选取可能不唯一。下面给出加法函数的两种定义，都可以被 Coq 接受。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint plus (n m : nat) : nat :=</span><br><span class="line">match n with</span><br><span class="line">| O =&gt; m</span><br><span class="line">| S n&#x27; =&gt; S (plus n&#x27; m)</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint plus&#x27; (n m : nat) : nat :=</span><br><span class="line">match m with</span><br><span class="line">| O =&gt; n</span><br><span class="line">| S m&#x27; =&gt; S (plus n m&#x27;)</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><h2 id="占位符“-”"><a href="#占位符“-”" class="headerlink" title="占位符“_”"></a>占位符“_”</h2><p>有时候我们可以同时对多个参数做模式匹配，不同参数之间用逗号隔开。下面定义的减法函数演示了这一点，其中不重要的参数可以不写，改用占位符“_” 代替。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint minus (n m : nat) : nat :=</span><br><span class="line">match n, m with</span><br><span class="line">| O , _ =&gt; O</span><br><span class="line">| S _ , O =&gt; n</span><br><span class="line">| S n&#x27;, S m&#x27; =&gt; minus n&#x27; m&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="嵌套的模式匹配"><a href="#嵌套的模式匹配" class="headerlink" title="嵌套的模式匹配"></a>嵌套的模式匹配</h2><p>当然，我们也可以把对多个参数的同时模式匹配改为嵌套的模式匹配。下面定义的函数 minus’ 与 minus 是等效的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint minus&#x27; (n m : nat) : nat :=</span><br><span class="line">match n with</span><br><span class="line">| O =&gt; O</span><br><span class="line">| S n&#x27; =&gt; match m with</span><br><span class="line">| O =&gt; n</span><br><span class="line">| S m&#x27; =&gt; minus&#x27; n&#x27; m&#x27;</span><br><span class="line">end</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><h2 id="二元组"><a href="#二元组" class="headerlink" title="二元组"></a>二元组</h2><p>上一节介绍的布尔类型和自然数类型都是基本数据类型。现在我们从基本类型出发来构造复杂一些的类型。我们先定义二元组（pair）类型，它包含的每一个元素是一对自然数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inductive natpair : Type :=</span><br><span class="line">| pair (n1 n2 : nat).</span><br></pre></td></tr></table></figure><p>类型 natpair 只有一个构造子 pair，说明构造一对自然数的唯一方法是把pair 作用到两个自然数上。</p><p>下面我们定义两个投影（projection）函数，把给定的一对自然数投影到第一或第二个组成数字上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Definition proj1 (p : natpair) : nat :=</span><br><span class="line">match p with</span><br><span class="line">| (x,y) =&gt; x</span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line">Definition proj2 (p : natpair) : nat :=</span><br><span class="line">match p with</span><br><span class="line">| (x,y) =&gt; y</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>例如，下面的命令测试如何把一对数字 (1, 2) 变成 (2, 1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compute (proj2 (1, 2), proj1 (1, 2)).</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>通过推广二元组类型，我们可以构建三元组、四元组等等，更一般情况就是列表，其长度可以变化。简单而言，由自然数组成的一个列表或者是空表，或者是由一个自然数和另一个列表组成的二元组。我们在模块 NatList 中定义自然数列表类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inductive natlist : Type :=</span><br><span class="line">| nil</span><br><span class="line">| cons (n : nat) (l : natlist).</span><br></pre></td></tr></table></figure><p>这个定义中用到两个构造子：nil 表示空表；cons 把自然数 n 和列表 l 组合成一个更长的列表 cons n l。</p><p>我们引入中缀操作符记号 :: 和方括号来表示列表，其中细节暂时不用关心。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Definition list1 := 1 :: (3 :: (5 :: nil)).</span><br><span class="line">Definition list2 := 1 :: 3 :: 5 :: nil.</span><br><span class="line">Definition list3 := [1;3;5].</span><br></pre></td></tr></table></figure><p>利用这些记号，我们定义 3 个列表，实际上描述的是同一个列表。</p><p>下面我们定义一些有用的函数，方便对列表进行操纵。函数 repeat 有两个输入参数 n 和 count，它返回一个长度为 count 的列表，其中每个元素都是 n。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint repeat (n count : nat) : natlist :=</span><br><span class="line">match count with</span><br><span class="line">| O =&gt; nil</span><br><span class="line">| S count&#x27; =&gt; n :: (repeat n count&#x27;)</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>函数 length 可用于计算一个列表的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint length (l:natlist) : nat :=</span><br><span class="line">match l with</span><br><span class="line">| nil =&gt; O</span><br><span class="line">| h :: t =&gt; S (length t)</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><div><div style="text-align:center;color:#ccc;font-size:14px">------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div></div><div class="reward-container"><div>只想买包辣条</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="哂笑 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="哂笑 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>哂笑</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://www.example.com/2023/03/24/Coq-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" title="Coq Basics (I)">http://www.example.com/2023/03/24/Coq-基本的函数式编程/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/coq/" rel="tag"># coq</a></div><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a href="/2023/03/28/LISTS-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88coq%EF%BC%89/" rel="next" title="Coq Basics (II)">Coq Basics (II) <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC81ODIzMS8zNDY5NA"></div></div><script>window.addEventListener("tabs:register",()=>{let t=CONFIG.comments["activeClass"];var e;(t=CONFIG.comments.storage?localStorage.getItem("comments_active")||t:t)&&(e=document.querySelector(`a[href="#comment-${t}"]`))&&e.click()}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#inductive"><span class="nav-number">1.</span> <span class="nav-text">inductive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">枚举类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">布尔类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Notation-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">Notation 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tactics"><span class="nav-number">6.</span> <span class="nav-text">Tactics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#simpl%E5%92%8Creflexivity-%E5%8C%96%E7%AE%80"><span class="nav-number">6.1.</span> <span class="nav-text">simpl和reflexivity-化简</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rewrite-%E9%87%8D%E5%86%99"><span class="nav-number">6.2.</span> <span class="nav-text">rewrite-重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#destruct"><span class="nav-number">6.3.</span> <span class="nav-text">destruct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#induction-%E5%81%87%E8%AE%BE%E5%BD%92%E7%BA%B3"><span class="nav-number">6.4.</span> <span class="nav-text">induction-假设归纳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assert-%E8%A1%8C%E9%97%B4%E8%AF%81%E6%98%8E"><span class="nav-number">6.5.</span> <span class="nav-text">assert-行间证明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">自然数类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fixpoint"><span class="nav-number">8.</span> <span class="nav-text">Fixpoint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6%E2%80%9C-%E2%80%9D"><span class="nav-number">9.</span> <span class="nav-text">占位符“_”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">10.</span> <span class="nav-text">嵌套的模式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E7%BB%84"><span class="nav-number">11.</span> <span class="nav-text">二元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-number">12.</span> <span class="nav-text">列表</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="哂笑" src="/images/avatar.png"><p class="site-author-name" itemprop="name">哂笑</p><div class="site-description" itemprop="description">输出倒逼思考</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/shenxiao233" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shenxiao233" rel="noopener" target="_blank"><i class="custom github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yzw3503222022@163.com" title="E-Mail → mailto:yzw3503222022@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a></span></div></div><div class="links-of-recent-posts motion-element"><div class="links-of-recent-posts-title"><i class="fa fa-history fa-fw"></i> 最近文章</div><ul class="links-of-recent-posts-list"><li class="links-of-recent-posts-item"><a href="/2023/05/16/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" title="2023&#x2F;05&#x2F;16&#x2F;数学建模&#x2F;">matlab review (I)</a></li><li class="links-of-recent-posts-item"><a href="/2023/04/24/apply%20%E7%AD%96%E7%95%A5/" title="2023&#x2F;04&#x2F;24&#x2F;apply 策略&#x2F;">Coq Basics (IV)</a></li><li class="links-of-recent-posts-item"><a href="/2023/04/24/%E5%A4%9A%E6%80%81%E5%88%97%E8%A1%A8/" title="2023&#x2F;04&#x2F;24&#x2F;多态列表&#x2F;">Coq Basics (III)</a></li><li class="links-of-recent-posts-item"><a href="/2023/03/28/LISTS-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88coq%EF%BC%89/" title="2023&#x2F;03&#x2F;28&#x2F;LISTS-使用结构化的数据（coq）&#x2F;">Coq Basics (II)</a></li><li class="links-of-recent-posts-item"><a href="/2023/03/24/Coq-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" title="2023&#x2F;03&#x2F;24&#x2F;Coq-基本的函数式编程&#x2F;">Coq Basics (I)</a></li></ul></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i></i> </span><span class="author" itemprop="copyrightHolder">哂笑</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">30k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">27 分钟</span></div><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referra"><img src="images/又拍云_logo.png" align="absmiddle" width="59px" height="30px"></a><span>提供CDN加速/云储存服务</span></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/code-unfold.js"></script><script>!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector("#lv-container"),()=>{var e,t,r;window.livereOptions={refer:location.pathname.replace(CONFIG.root,"").replace("index.html","")},e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((e=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",e.async=!0,r.parentNode.insertBefore(e,r))})</script></body></html><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#4d4d4c;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#f7f7f7;background-image:linear-gradient(#f7f7f7,#f7f7f7);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),e=(document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus(),document.execCommand("copy"));document.body.removeChild(n),e?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script>