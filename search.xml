<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Coq Basics (IV)</title>
    <url>/2023/04/24/apply%20%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="apply-策略"><a href="#apply-策略" class="headerlink" title="apply 策略"></a>apply 策略</h2><p>我们经常会遇到待证目标与上下文中的前提或已证引理’刚好相同’的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem silly1 : ∀ (n m o p : nat),</span><br><span class="line">     n = m →</span><br><span class="line">     [n;o] = [n;p] →</span><br><span class="line">     [n;o] = [m;p].</span><br><span class="line">Proof.</span><br><span class="line">  intros n m o p eq1 eq2.</span><br><span class="line">  rewrite &lt;- eq1.</span><br></pre></td></tr></table></figure>

<p>我们可以像之前那样用“rewrite → eq2. reflexivity.”来完成。 不过如果我们使用 apply 策略，只需一步就能完成此证明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply eq2. Qed.</span><br></pre></td></tr></table></figure>

<p>apply 策略也可以配合’条件（Conditional）’假设和引理来使用： 如果被应用的语句是一个蕴含式，那么该蕴含式的前提就会被添加到待证子目标列表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem silly2 : ∀ (n m o p : nat),</span><br><span class="line">    n = m →</span><br><span class="line">    (n = m → [n;o] = [m;p]) →</span><br><span class="line">    [n;o] = [m;p].</span><br><span class="line">Proof.</span><br><span class="line">  intros n m o p eq1 eq2.</span><br><span class="line">  apply eq2. apply eq1. Qed.</span><br></pre></td></tr></table></figure>

<p>通常，当我们使用 apply H 时，语句 H 会以一个引入了某些 ‘通用变量（Universal Variables）’ 的 ∀ 开始。在 Coq 针对 H 的结论匹配当前目标时，它会尝试为这些变量查找适当的值。例如， 当我们在以下证明中执行 apply eq2 时，eq2 中的通用变量 q 会以 n 实例化，而 r 会以 m 实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem silly2a : ∀ (n m : nat),</span><br><span class="line">     (n,n) = (m,m) →</span><br><span class="line">     (∀ (q r : nat), (q,q) = (r,r) → [q] = [r]) →</span><br><span class="line">     [n] = [m].</span><br><span class="line">Proof.</span><br><span class="line">  intros n m eq1 eq2.</span><br><span class="line">  apply eq2. apply eq1. Qed.</span><br></pre></td></tr></table></figure>

<p>要使用 apply 策略，被应用的事实（的结论）必须精确地匹配证明目标： 例如, 当等式的左右两边互换后，apply 就无法起效了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem silly3_firsttry : ∀ (n : nat),</span><br><span class="line">     true = (n =? 5) →</span><br><span class="line">     (S (S n)) =? 7 = true.</span><br><span class="line">Proof.</span><br><span class="line">  intros n H.</span><br></pre></td></tr></table></figure>

<p>在这里，我们无法直接使用 apply，不过我们可以用 symmetry 策略 它会交换证明目标中等式的左右两边。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symmetry.</span><br><span class="line">  simpl.</span><br></pre></td></tr></table></figure>

<p>（此处的 simpl 是可选的，因为 apply 会在需要时先进行化简。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply H. Qed.</span><br></pre></td></tr></table></figure>

<h2 id="apply-with-策略"><a href="#apply-with-策略" class="headerlink" title="apply with 策略"></a>apply with 策略</h2><p>以下例子在一行中使用了两次改写来将 [a;b] 变成 [e;f]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example trans_eq_example : ∀ (a b c d e f : nat),</span><br><span class="line">     [a;b] = [c;d] →</span><br><span class="line">     [c;d] = [e;f] →</span><br><span class="line">     [a;b] = [e;f].</span><br><span class="line">Proof.</span><br><span class="line">  intros a b c d e f eq1 eq2.</span><br><span class="line">  rewrite → eq1. rewrite → eq2. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>由于这种模式十分常见，因此我们希望一劳永逸地把它作为一条引理记录下来， 即等式具有传递性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem trans_eq : ∀ (X:Type) (n m o : X),</span><br><span class="line">  n = m → m = o → n = o.</span><br><span class="line">Proof.</span><br><span class="line">  intros X n m o eq1 eq2. rewrite → eq1. rewrite → eq2.</span><br><span class="line">  reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>现在，按理说我们应该可以用 trans_eq 来证明前面的例子了。 然而，为此我们还需要稍微改进一下 apply 策略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example trans_eq_example&#x27; : ∀ (a b c d e f : nat),</span><br><span class="line">     [a;b] = [c;d] →</span><br><span class="line">     [c;d] = [e;f] →</span><br><span class="line">     [a;b] = [e;f].</span><br><span class="line">Proof.</span><br><span class="line">  intros a b c d e f eq1 eq2.</span><br></pre></td></tr></table></figure>

<p>如果此时我们只是告诉 Coq apply trans_eq，那么它会 （根据该引理的结论对证明目标的匹配）说 X 应当实例化为 [nat]、n 实例化为 [a,b]、以及 o 实例化为 [e,f]。然而，匹配过程并没有为 m 确定实例：我们必须在 apply 的调用后面加上 “with (m:&#x3D;[c,d])” 来显式地提供一个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply trans_eq with (m:=[c;d]).</span><br><span class="line">  apply eq1. apply eq2. Qed.</span><br></pre></td></tr></table></figure>

<p>（实际上，我们通常不必在 with 从句中包含名字 m，Coq 一般足够聪明来确定我们实例化的变量。我们也可以写成： apply trans_eq with [c;d]。）</p>
<h2 id="The-injection-and-discriminate-Tactics"><a href="#The-injection-and-discriminate-Tactics" class="headerlink" title="The injection and discriminate Tactics"></a>The injection and discriminate Tactics</h2><p>回想自然数的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive nat : Type :=</span><br><span class="line">       | O</span><br><span class="line">       | S (n : nat).</span><br></pre></td></tr></table></figure>

<p>我们可从该定义中观察到，所有的数都是两种形式之一：要么是构造子 O， 要么就是将构造子 S 应用到另一个数上。不过这里还有无法直接看到的： 自然数的定义中还蕴含了两个事实：</p>
<p>构造子 S 是’单射（Injective）’或’一一对应’的。 即，如果 S n &#x3D; S m，那么 n &#x3D; m 必定成立。<br>构造子 O 和 S 是’不相交（Disjoint）’的。 即，对于任何 n，O 都不等于 S n。</p>
<p>类似的原理同样适用于所有归纳定义的类型：所有构造子都是单射的， 而不同构造子构造出的值绝不可能相等。对于列表来说，cons 构造子是单射的， 而 nil 不同于任何非空列表。对于布尔值来说，true 和 false 是不同的。 因为 true 和 false 二者都不接受任何参数，它们既不在这边也不在那边。 其它归纳类型亦是如此。</p>
<p>例如，我们可以使用定义在 Basics.v 中的 pred 函数来证明 S 的单射性。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem S_injective : ∀ (n m : nat),</span><br><span class="line">  S n = S m →</span><br><span class="line">  n = m.</span><br><span class="line">Proof.</span><br><span class="line">  intros n m H1.</span><br><span class="line">  assert (H2: n = pred (S n)). &#123; reflexivity. &#125;</span><br><span class="line">  rewrite H2. rewrite H1. reflexivity.</span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>

<p>我们可从该定义中观察到，所有的数都是两种形式之一：要么是构造子 O， 要么就是将构造子 S 应用到另一个数上。不过这里还有无法直接看到的： 自然数的定义中还蕴含了两个事实：<br>构造子 S 是’单射（Injective）’或’一一对应’的。 即，如果 S n &#x3D; S m，那么 n &#x3D; m 必定成立。<br>构造子 O 和 S 是’不相交（Disjoint）’的。 即，对于任何 n，O 都不等于 S n。</p>
<p>类似的原理同样适用于所有归纳定义的类型：所有构造子都是单射的， 而不同构造子构造出的值绝不可能相等。对于列表来说，cons 构造子是单射的， 而 nil 不同于任何非空列表。对于布尔值来说，true 和 false 是不同的。 因为 true 和 false 二者都不接受任何参数，它们既不在这边也不在那边。 其它归纳类型亦是如此。</p>
<p>例如，我们可以使用定义在 Basics.v 中的 pred 函数来证明 S 的单射性。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem S_injective : ∀ (n m : nat),</span><br><span class="line">  S n = S m →</span><br><span class="line">  n = m.</span><br><span class="line">Proof.</span><br><span class="line">  intros n m H1.</span><br><span class="line">  assert (H2: n = pred (S n)). &#123; reflexivity. &#125;</span><br><span class="line">  rewrite H2. rewrite H1. reflexivity.</span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>

<p>这个技巧可以通过编写等价的 pred 来推广到任意的构造子上 —— 即编写一个“撤销”一次构造子调用的函数。为此，Coq 提供了更加简便的 injection 策略，它能让我们利用任意构造子的单射性。 下面是使用 injection 对上面定理的另一种证法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem S_injective&#x27; : ∀ (n m : nat),</span><br><span class="line">  S n = S m →</span><br><span class="line">  n = m.</span><br><span class="line">Proof.</span><br><span class="line">  intros n m H.</span><br></pre></td></tr></table></figure>

<p>通过在此处编写 injection H as Hmn，我们让 Coq 利用构造子的单射性来产生所有它能从 H 所推出的等式（本例中为等式 n &#x3D; m）。 每一个这样的等式都作为假设（本例中为 Hmn）被添加到上下文中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">injection H as Hnm. apply Hnm.</span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>

<p>以下例子展示了一个 injection 如何直接得出多个等式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem injection_ex1 : ∀ (n m o : nat),</span><br><span class="line">  [n; m] = [o; o] →</span><br><span class="line">  [n] = [m].</span><br><span class="line">Proof.</span><br><span class="line">  intros n m o H.</span><br><span class="line">  (* 课上已完成 *)</span><br><span class="line">  injection H as H1 H2.</span><br><span class="line">  rewrite H1. rewrite H2. reflexivity.</span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>

<p>另一方面，如果你只使用 injection H 而不带 as 从句， 那么所有的等式都会在目标的开头被转变为假设。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem injection_ex2 : ∀ (n m o : nat),</span><br><span class="line">  [n; m] = [o; o] →</span><br><span class="line">  [n] = [m].</span><br><span class="line">Proof.</span><br><span class="line">  intros n m o H.</span><br><span class="line">  injection H.</span><br><span class="line">  (* 课上已完成 *)</span><br><span class="line">  intros H1 H2. rewrite H1. rewrite H2. reflexivity.</span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>

<h2 id="对假设使用策略"><a href="#对假设使用策略" class="headerlink" title="对假设使用策略"></a>对假设使用策略</h2><p>默认情况下，大部分策略会作用于目标公式并保持上下文不变。然而， 大部分策略还有对应的变体来对上下文中的语句执行类似的操作。<br>例如，策略 simpl in H 会对上下文中的假设 H 执行化简。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem S_inj : ∀ (n m : nat) (b : bool),</span><br><span class="line">     (S n) =? (S m) = b →</span><br><span class="line">     n =? m = b.</span><br><span class="line">Proof.</span><br><span class="line">  intros n m b H. simpl in H. apply H. Qed.</span><br></pre></td></tr></table></figure>

<p>类似地，apply L in H 会针对上下文中的假设 H 匹配某些 （形如 X → Y 中的）条件语句 L。然而，与一般的 apply 不同 （它将匹配 Y 的目标改写为子目标 X），apply L in H 会针对 X 匹配 H，如果成功，就将其替换为 Y。</p>
<p>换言之，apply L in H 给了我们一种“正向推理”的方式：根据 X → Y 和一个匹配 X 的假设，它会产生一个匹配 Y 的假设。作为对比，apply L 是一种“反向推理”：它表示如果我们知道 X → Y 并且试图证明 Y， 那么证明 X 就足够了。</p>
<p>下面是前面证明的一种变体，它始终使用正向推理而非反向推理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem silly3&#x27; : ∀ (n : nat),</span><br><span class="line">  (n =? 5 = true → (S (S n)) =? 7 = true) →</span><br><span class="line">  true = (n =? 5) →</span><br><span class="line">  true = ((S (S n)) =? 7).</span><br><span class="line">Proof.</span><br><span class="line">  intros n eq H.</span><br><span class="line">  symmetry in H. apply eq in H. symmetry in H.</span><br><span class="line">  apply H. Qed.</span><br></pre></td></tr></table></figure>

<p>正向推理从’给定’的东西开始（即前提、已证明的定理）， 根据它们迭代地刻画结论直到抵达目标。反向推理从’目标’开始， 迭代地推理蕴含目标的东西，直到抵达前提或已证明的定理。</p>
<p>你在数学或计算机科学课上见过的非形式化证明可能倾向于正向推理。 通常，Coq 习惯上倾向于使用反向推理，但在某些情况下，正向推理更易于思考。</p>
<h2 id="变换归纳假设"><a href="#变换归纳假设" class="headerlink" title="变换归纳假设"></a>变换归纳假设</h2><p>在 Coq 中进行归纳证明时，有时控制归纳假设的确切形式是十分重要的。 特别是，在调用 induction 策略前，我们有时需要用 intros 将假设从目标移到上下文中时要十分小心。例如，假设我们要证明 double 函数是单射的 – 即，它将不同的参数映射到不同的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem double_injective: ∀ n m,</span><br><span class="line">        double n = double m → n = m.</span><br></pre></td></tr></table></figure>

<p>此证明的开始方式有点微妙：如果我们以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intros n. induction n.</span><br></pre></td></tr></table></figure>

<p>开始，那么一切都好。然而假如以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intros n m. induction n.</span><br></pre></td></tr></table></figure>

<p>开始，就会卡在归纳情况中…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem double_injective_FAILED : ∀ n m,</span><br><span class="line">     double n = double m →</span><br><span class="line">     n = m.</span><br><span class="line">Proof.</span><br><span class="line">  intros n m. induction n as [| n&#x27; IHn&#x27;].</span><br><span class="line">  - (* n = O *) simpl. intros eq. destruct m as [| m&#x27;] eqn:E.</span><br><span class="line">    + (* m = O *) reflexivity.</span><br><span class="line">    + (* m = S m&#x27; *) discriminate eq.</span><br><span class="line">  - (* n = S n&#x27; *) intros eq. destruct m as [| m&#x27;] eqn:E.</span><br><span class="line">    + (* m = O *) discriminate eq.</span><br><span class="line">    + (* m = S m&#x27; *) apply f_equal.</span><br></pre></td></tr></table></figure>

<p>此时，归纳假设 IHn’ ‘不会’给出 n’ &#x3D; m’ – 会有个额外的 S 阻碍 – 因此该目标无法证明。</p>
<p>哪里出了问题？<br>问题在于，我们在调用归纳假设的地方已经将 m 引入了上下文中 – 直观上，我们已经告诉了 Coq“我们来考虑具体的 n 和 m…”， 而现在必须为那些’具体的’ n 和 m 证明 double n &#x3D; double m， 然后才有 n &#x3D; m。</p>
<p>下一个策略 induction n 告诉 Coq：我们要对 n 归纳来证明该目标。 也就是说，我们要证明对于’所有的’ n，命题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P n = &quot;if double n = double m, then n = m&quot;</span><br><span class="line">成立，需通过证明</span><br><span class="line">P O</span><br><span class="line">（即，若“double O = double m 则 O = m”）和</span><br><span class="line">P n → P (S n)</span><br><span class="line">（即，若“double n = double m 则 n = m”蕴含“若 double (S n) = double m 则 S n = m”）来得出。</span><br><span class="line">如果我们仔细观察第二个语句，就会发现它说了奇怪的事情：即，对于一个&#x27;具体的&#x27; m，如果我们知道</span><br><span class="line">“若 double n = double m 则 n = m”</span><br><span class="line">那么我们就能证明</span><br><span class="line">“若 double (S n) = double m 则 S n = m”。</span><br><span class="line">要理解为什么它很奇怪，我们来考虑一个具体的（任意但确定的）m -- 比如说 5。该语句就会这样说：如果我们知道</span><br><span class="line">Q = “若 double n = 10 则 n = 5”</span><br><span class="line">那么我们就能证明</span><br><span class="line">R = “若 double (S n) = 10 则 S n = 5”。</span><br></pre></td></tr></table></figure>

<p>但是知道 Q 对于证明 R 来说并没有任何帮助！（如果我们试着根据 Q 证明 R，就会以“假设 double (S n) &#x3D; 10..”这样的句子开始， 不过之后我们就会卡住：知道 double (S n) 为 10 并不能告诉我们 double n 是否为 10。（实际上，它强烈地表示 double n ‘不是’ 10！） 因此 Q 是没有用的。）</p>
<p>当 m 已经在上下文中时，试图对 n 进行归纳来进行此证明是行不通的， 因为我们之后要尝试证明涉及’每一个’ n 的命题，而不只是’单个’ m。</p>
<p>对 double_injective 的成功证明将 m 留在了目标语句中 induction 作用于 n 的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem double_injective : ∀ n m,</span><br><span class="line">     double n = double m →</span><br><span class="line">     n = m.</span><br><span class="line">Proof.</span><br><span class="line">  intros n. induction n as [| n&#x27; IHn&#x27;].</span><br><span class="line">  - (* n = O *) simpl. intros m eq. destruct m as [| m&#x27;] eqn:E.</span><br><span class="line">    + (* m = O *) reflexivity.</span><br><span class="line">    + (* m = S m&#x27; *) discriminate eq.</span><br><span class="line">  - (* n = S n&#x27; *) simpl.</span><br></pre></td></tr></table></figure>

<p>注意，此时的证明目标和归纳假设是不同的：证明目标要求我们证明更一般的事情 （即，为’每一个’ m 证明该语句），而归纳假设 IH 相应地更加灵活， 允许我们在应用归纳假设时选择任何想要的 m。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intros m eq.</span><br></pre></td></tr></table></figure>

<p>现在我们选择了一个具体的 m 并引入了假设 double n &#x3D; double m。 由于我们对 n 做了情况分析，因此还要对 m 做情况分析来保持两边“同步”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">destruct m as [| m&#x27;] eqn:E.</span><br><span class="line">    + (* m = O *) simpl.</span><br></pre></td></tr></table></figure>

<p>0 的情况很显然：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">discriminate eq.</span><br><span class="line">   + (* m = S m&#x27; *)</span><br><span class="line">     apply f_equal.</span><br></pre></td></tr></table></figure>

<p>到这里，由于我们在 destruct m 的第二个分支中，因此上下文中涉及到的 m’ 就是我们开始讨论的 m 的前趋。由于我们也在归纳的 S 分支中，这就很完美了： 如果我们在归纳假设中用当前的 m’（此实例由下一步的 apply 自动产生） 实例化一般的 m，那么 IHn’ 就刚好能给出我们需要的来结束此证明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply IHn&#x27;. injection eq as goal. apply goal. Qed.</span><br></pre></td></tr></table></figure>

<h2 id="展开定义"><a href="#展开定义" class="headerlink" title="展开定义"></a>展开定义</h2><p>现在，是时候讨论下展开和化简了。<br>我们已经观察到，像 simpl、reflexivity 和 apply 这样的策略， 通常总会在需要时自动展开函数的定义。例如，若我们将 foo m 定义为常量 5…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition foo (x: nat) := 5.</span><br></pre></td></tr></table></figure>

<p>那么在以下证明中 simpl（或 reflexivity，如果我们忽略 simpl） 就会将 foo m 展开为 (fun x ⇒ 5) m 并进一步将其化简为 5。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fact silly_fact_1 : ∀ m, foo m + 1 = foo (m + 1) + 1.</span><br><span class="line">Proof.</span><br><span class="line">  intros m.</span><br><span class="line">  simpl.</span><br><span class="line">  reflexivity.</span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>

<p>然而，这种自动展开有些保守。例如，若我们用模式匹配定义稍微复杂点的函数…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition bar x :=</span><br><span class="line">  match x with</span><br><span class="line">  | O ⇒ 5</span><br><span class="line">  | S _ ⇒ 5</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>…那么类似的证明就会被卡住：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fact silly_fact_2_FAILED : ∀ m, bar m + 1 = bar (m + 1) + 1.</span><br><span class="line">Proof.</span><br><span class="line">  intros m.</span><br><span class="line">  simpl. (* 啥也没做！ *)</span><br><span class="line">Abort.</span><br></pre></td></tr></table></figure>

<p>simpl 没有进展的原因在于，它注意到在试着展开 bar m 之后会留下被匹配的 m，它是一个变量，因此 match 无法被进一步化简。它还没有聪明到发现 match 的两个分支是完全相同的。因此它会放弃展开 bar m 并留在那。 </p>
<p>类似地，在试着展开 bar (m+1) 时会留下一个 match，被匹配者是一个函数应用 （即它本身，即便在展开 + 的定义后也无法被化简），因此 simpl 会留下它。</p>
<p>此时有两种方法可以继续。一种是用 destruct m 将证明分为两种情况， 每一种都关注于更具体的 m（O vs S _）。在这两种情况下， bar 中的 match 可以继续了，证明则很容易完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fact silly_fact_2 : ∀ m, bar m + 1 = bar (m + 1) + 1.</span><br><span class="line">Proof.</span><br><span class="line">  intros m.</span><br><span class="line">  destruct m eqn:E.</span><br><span class="line"></span><br><span class="line">  - simpl. reflexivity.</span><br><span class="line">  - simpl. reflexivity.</span><br><span class="line">    Qed.</span><br></pre></td></tr></table></figure>

<p>这种方法是可行的，不过它依赖于我们能发现隐藏在 bar 中的 match 阻碍了证明的进展。<br>一种更直白的方式就是明确地告诉 Coq 去展开 bar。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fact silly_fact_2&#x27; : ∀ m, bar m + 1 = bar (m + 1) + 1.</span><br><span class="line">Proof.</span><br><span class="line">  intros m.</span><br><span class="line">  unfold bar.</span><br></pre></td></tr></table></figure>

<p>现在很明显，我们在 &#x3D; 两边的 match 上都卡住了，不用多想就能用 destruct 来结束证明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> destruct m eqn:E.</span><br><span class="line"> - reflexivity.</span><br><span class="line"> - reflexivity.</span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure>

<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>现在我们已经见过 Coq 中最基础的策略了。未来的章节中我们还会介绍更多， 之后我们会看到一些更加强大的*’自动化’*策略，它能让 Coq 帮我们处理底层的细节。 不过基本上我们已经有了完成工作所需的东西。</p>
<p>下面是我们已经见过的：</p>
<p><img src="https://raw.githubusercontent.com/shenxiao233/tupian_img/main/202305102104065.png" alt="基本策略"></p>
]]></content>
      <categories>
        <category>Coq</category>
      </categories>
      <tags>
        <tag>coq</tag>
      </tags>
  </entry>
  <entry>
    <title>Coq Basics (I)</title>
    <url>/2023/03/24/Coq-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="inductive"><a href="#inductive" class="headerlink" title="inductive"></a>inductive</h2><p>Inductive是Coq用来定义数据类型，实际上Coq的数据类型十分精简，但是我们可以通过这样的方法来自定义数据类型，Coq中最基本的数据类型就是Type，相当于Java的Object。语句的结构为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive [TYPE_NAME] : [INHERITED_TYPE] := &#123;IND_DEF&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive season : Type :=</span><br><span class="line">| spring</span><br><span class="line">| summer</span><br><span class="line">| autumn</span><br><span class="line">| winter.</span><br></pre></td></tr></table></figure>

<p>这个定义以关键字 Inductive 开头，说明是一个归纳定义，而紧跟其后的season : Type 声明 season 是我们新定义的一个类型。竖线隔开四种情况，spring、summer 等是类型构造子（type constructor），因为没带任何参数，可以简单理解为四个元素，它们组成一个集合，即名为 season 的类型所表示的集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition opposite_eason (s : season) : season :=</span><br><span class="line">match s with</span><br><span class="line">| spring =&gt; autumn</span><br><span class="line">| summer =&gt; winter</span><br><span class="line">| autumn =&gt; spring</span><br><span class="line">| winter =&gt; summer</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<p>定义一个名为 opposite_season 的函数，对输入的一个季节，返回与它相反的季节，因此输入和输出的类型均为 season，换句话说，这个函数自身的类型是 season → season。</p>
<p>在具体定义中我们以模式匹配（pattern matching）的方式，区分 s 的不同形式。如果 s 是 spring，则返回 autumn；如果是 summer，则返回 winter，等等。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Coq 中的每个表达式都有类型，它描述了该表达式所计算的东西的类别。 Check 指令会让 Coq 显示一个表达式的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check true.</span><br><span class="line">(* ===&gt; true : bool *)</span><br></pre></td></tr></table></figure>

<p>如果在被 Check 的表达式后加上一个分号和你想验证的类型，那么 Coq 会 验证该表达式是否属于你提供的类型。当两者不一致时，Coq 会报错并终止执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check true</span><br><span class="line">    : bool.</span><br></pre></td></tr></table></figure>

<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive bool : Type :=</span><br><span class="line">| true</span><br><span class="line">| false.</span><br></pre></td></tr></table></figure>

<p>布尔类型实际上是一个特殊的枚举类型，它只包含两个数据值，在这里我们不妨称为 true 和 false。</p>
<p>对布尔类型数据的常用操作如“与”、“或”、“非”等都容易定义。例如，我们定义函数 andb 来表示“与”操作。这个函数输入两个参数 b1 和 b2，如果b1 的值为 true，直接返回 b2 的值，否则返回 false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition andb (b1 : bool) (b2 : bool) : bool :=</span><br><span class="line">match b1 with</span><br><span class="line">| true =&gt; b2</span><br><span class="line">| false =&gt; false</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<p>上面这个函数的两个输入参数类型相同，在 Coq 中可以写得紧凑一点，依次列出两个参数，中间用空格隔开，最后写上类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition andb (b1 b2 : bool) : bool :=</span><br><span class="line">match b1 with</span><br><span class="line">| true =&gt; b2</span><br><span class="line">| false =&gt; false</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<h2 id="Notation-命令"><a href="#Notation-命令" class="headerlink" title="Notation 命令"></a>Notation 命令</h2><p>Notation 命令可以用来定义新的记号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Notation &quot;x &amp;&amp; y&quot; := (andb x y).</span><br></pre></td></tr></table></figure>

<p>有个这个记号以后，将来如果我们写表达式 (b1 &amp;&amp; b2)，那么代表的意思就是 (andb b1 b2)，这类似有些编程语言中的宏定义。</p>
<h2 id="Tactics"><a href="#Tactics" class="headerlink" title="Tactics"></a>Tactics</h2><h3 id="simpl和reflexivity-化简"><a href="#simpl和reflexivity-化简" class="headerlink" title="simpl和reflexivity-化简"></a>simpl和reflexivity-化简</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem plus_O_n: forall n : nat, o + n = n Proof. intros n. simpl. reflexitivity. Qed.</span><br></pre></td></tr></table></figure>

<p>这个证明只用了simpl和reflexivity两种方法。simpl可以将等式的两边同时化简(simplify)，而reflexivity是用来检查等式的两边是否完全一致(identical)。一般情况下，不需要加simpl，因为reflexivity本身在检查一致性的时候，就会自动的进行展开，如果需要在调试的时候查看化简之后的效果才会加上simpl。</p>
<p>reflexivity除了进行化简的工作，还会根据定义将产生式展开(unfolding)。化简和展开的区别在于，化简是将定义的函数（比如递归函数）化简到稳定的状态（对于递归函数，就是Base case）；展开则是利用产生式的构造子完整的写出数据的形式。</p>
<p>能够化简的一个前提条件是，函数能够无歧义的化简（上文中n + o &#x3D; n就不能够化简证明，需要分情况证明）。</p>
<h3 id="rewrite-重写"><a href="#rewrite-重写" class="headerlink" title="rewrite-重写"></a>rewrite-重写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem plus_id_example : forall n m:nat,</span><br><span class="line">n = m -&gt; n + n = m + m. Proof. </span><br><span class="line">(* move both quantifiers into the context: *)</span><br><span class="line">intros n m. </span><br><span class="line">(* move the hypothesis into the context: *) </span><br><span class="line">intros H. </span><br><span class="line">(* rewrite the goal using the hypothesis: *)</span><br><span class="line">rewrite -&gt; H. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>重写(rewriting)指的是，在证明的过程中，按照给出的前提假设(Hypothesis)，在要证明的式子两边对变量进行改写，辅助证明。</p>
<p>-&gt;表示的意思是使用前提假设的右侧替换左侧，&lt;-表示左侧替换右侧。</p>
<p>对于上面的证明过程，我们无法指出所有可能的取值，因此证明的时候无法进行相应的确切的化简，因此需要改写变量满足假设进行证明，该重写过程就是n + n &#x3D; m + m (<em>–&gt;</em>) m + m &#x3D; m + m</p>
<h3 id="destruct"><a href="#destruct" class="headerlink" title="destruct"></a>destruct</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem surjective_pairing : forall (p : natprod), p = (fst p, snd p). </span><br><span class="line">Proof. intros p.</span><br><span class="line">destruct p as [n m]. </span><br><span class="line">simpl. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem plus_1_neq_0 : </span><br><span class="line">forall n : nat, beq_nat (n + 1) 0 = false.</span><br><span class="line">Proof. intros n. </span><br><span class="line">destruct n as [| n&#x27;].</span><br><span class="line">- reflexivity. - reflexivity. Qed.</span><br></pre></td></tr></table></figure>
<p>上述代码可以改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem plus_1_neq_0&#x27; : </span><br><span class="line">forall n :nat, beq_nat (n + 1) 0 = false. </span><br><span class="line">Proof. intros [|n]. </span><br><span class="line">- reflexivity.</span><br><span class="line">- reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>使用destruct对引入的参数进行分情况讨论，设置子目标(sub goal)，分别进行证明。分情况讨论允许多层的嵌套，在需要进行分情况讨论的地方进行destruct。</p>
<p>每个子目标前面的-没有语法含义，可以替换为+或者*。</p>
<p>destruct后面的中括号参数是根据类型的定义设置的，如果出现多种情况就是用|隔开。对于nat的定义，第一个构造子(constructor)并无参数，因此为空，第二个构造器的参数也是nat，因此需要指明参数名称。如果构造器都没有参数，那就可以省略as子句。</p>
<h3 id="induction-假设归纳"><a href="#induction-假设归纳" class="headerlink" title="induction-假设归纳"></a>induction-假设归纳</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem plus_n_O : </span><br><span class="line">forall n:nat, n = n + 0. </span><br><span class="line">Proof. intros n. </span><br><span class="line">induction n as [| n&#x27; IHn&#x27;].</span><br><span class="line">- (* n = 0 *) reflexivity. </span><br><span class="line">- (* n = S n&#x27; *) simpl. rewrite &lt;- IHn&#x27;. </span><br><span class="line">reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>那上述的证明来说明，n可以是任意大的自然数，如果按照分情况讨论的话，可能会一直化简下去，并不能验证任意大小的n。这种情况下，使用类似于数学归纳法进行证明，即induction，归纳证明命题的正确性。</p>
<p>归纳induction的语法结构同样类似与destruct，产生的不同的子目标，进行归纳证明。产生的子目标也同样根据参数的构造方法有关，并使用|区分不同构造子情况，并在之后子目标的论证用-、+或者*加以区别。induction可以提供关于子目标环境下的参数命名，也可以对子目标环境下的假设(hypothesis)进行命名（在上述论证中就是IHn’，代表着n’ &#x3D; n’ + 0），在该子目标下进行重写，进行进一步的论证。</p>
<h3 id="assert-行间证明"><a href="#assert-行间证明" class="headerlink" title="assert-行间证明"></a>assert-行间证明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem mult_0_plus&#x27; : </span><br><span class="line">forall n m :nat, (0 + n) * m = n * m.</span><br><span class="line">Proof. intros n m. </span><br><span class="line">assert (H: 0 + n = n). &#123; reflexivity. &#125; </span><br><span class="line">rewrite → H. </span><br><span class="line">reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>如果在证明的过程中需要加入临时的、显而易见的中间引理证明，那么可以考虑assert进行证明内的小引理证明(subtheorem)。assert这种方式引入了两个子目标，第一个便是断言(assertion)本身（在上述的论证中，断言被命名为H，指的是0+n&#x3D;0），这个子目标的论证囊括在大括号…中。另一个子目标就是在既有断言基础上进行原先的论证，通常也是通过重写来完成。</p>
<p>断言的方式主要是提供一种类似于匿名函数的功能。</p>
<h2 id="自然数类型"><a href="#自然数类型" class="headerlink" title="自然数类型"></a>自然数类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive nat : Type :=</span><br><span class="line">| O</span><br><span class="line">| S (n : nat).</span><br><span class="line">End Playground.</span><br></pre></td></tr></table></figure>

<p>O 表示自然数 0；S 表示后继函数，如果 n 是一个自然数，则 S n表示它的下一个自然数。</p>
<p>O, S O, S (S O), S (S (S O)), …对应通常的自然数 0, 1, 2, 3, ….。</p>
<p>例如，下面的 pred2 函数取比当且输入数 n 小 2 的数，除了特殊情况 n &#x3D; 0, 1，那时返回值为 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition pred2 (n : nat) : nat :=</span><br><span class="line">match n with</span><br><span class="line">| O =&gt; O</span><br><span class="line">| S O =&gt; O</span><br><span class="line">| S (S n&#x27;) =&gt; n&#x27;</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<h2 id="Fixpoint"><a href="#Fixpoint" class="headerlink" title="Fixpoint"></a>Fixpoint</h2><p>Fixpoint允许递归的调用本身，但是这种调用必须是一种有界的。因此，Fixpoint函数中所匹配(match)的参数必须是以降序的方式进行展开，确保不会无限递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint plus (n : nat) (m : nat) : nat := </span><br><span class="line">match n with</span><br><span class="line">| O ⇒ m </span><br><span class="line">| S n&#x27; ⇒ S (plus n&#x27; m) end.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint beq_nat (n m : nat) : bool :=</span><br><span class="line">match n with</span><br><span class="line">| O ⇒ match m with </span><br><span class="line">| O ⇒ true </span><br><span class="line">| S m&#x27; ⇒ false end </span><br><span class="line">| S n&#x27; ⇒ match m with </span><br><span class="line">         | O ⇒ false </span><br><span class="line">         | S m&#x27; ⇒ beq_nat n&#x27; m&#x27; end end.</span><br></pre></td></tr></table></figure>

<p>为定义复杂一些的函数，仅用模式匹配还不够，我们需要递归定义，反映到语法层面就是定义的开头用关键字 Fixpoint 而不是 Definition。下面的函数 oddb 可判断当 n 取 0 或者 1 时，我们直接判断出结果，否则，n 是不是奇数这件事情依赖于 n 之前第二个数字的奇偶性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint oddb (n : nat) : bool :=</span><br><span class="line">match n with</span><br><span class="line">| O =&gt; false</span><br><span class="line">| S O =&gt; true</span><br><span class="line">| S (S n&#x27;) =&gt; oddb n&#x27;</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<p>如果一个函数的参数不止一个，那么用于模式匹配的参数选取可能不唯一。下面给出加法函数的两种定义，都可以被 Coq 接受。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint plus (n m : nat) : nat :=</span><br><span class="line">match n with</span><br><span class="line">| O =&gt; m</span><br><span class="line">| S n&#x27; =&gt; S (plus n&#x27; m)</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint plus&#x27; (n m : nat) : nat :=</span><br><span class="line">match m with</span><br><span class="line">| O =&gt; n</span><br><span class="line">| S m&#x27; =&gt; S (plus n m&#x27;)</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<h2 id="占位符“-”"><a href="#占位符“-”" class="headerlink" title="占位符“_”"></a>占位符“_”</h2><p>有时候我们可以同时对多个参数做模式匹配，不同参数之间用逗号隔开。下面定义的减法函数演示了这一点，其中不重要的参数可以不写，改用占位符“_” 代替。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint minus (n m : nat) : nat :=</span><br><span class="line">match n, m with</span><br><span class="line">| O , _ =&gt; O</span><br><span class="line">| S _ , O =&gt; n</span><br><span class="line">| S n&#x27;, S m&#x27; =&gt; minus n&#x27; m&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="嵌套的模式匹配"><a href="#嵌套的模式匹配" class="headerlink" title="嵌套的模式匹配"></a>嵌套的模式匹配</h2><p>当然，我们也可以把对多个参数的同时模式匹配改为嵌套的模式匹配。下面定义的函数 minus’ 与 minus 是等效的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint minus&#x27; (n m : nat) : nat :=</span><br><span class="line">match n with</span><br><span class="line">| O =&gt; O</span><br><span class="line">| S n&#x27; =&gt; match m with</span><br><span class="line">| O =&gt; n</span><br><span class="line">| S m&#x27; =&gt; minus&#x27; n&#x27; m&#x27;</span><br><span class="line">end</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<h2 id="二元组"><a href="#二元组" class="headerlink" title="二元组"></a>二元组</h2><p>上一节介绍的布尔类型和自然数类型都是基本数据类型。现在我们从基本类型出发来构造复杂一些的类型。我们先定义二元组（pair）类型，它包含的每一个元素是一对自然数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive natpair : Type :=</span><br><span class="line">| pair (n1 n2 : nat).</span><br></pre></td></tr></table></figure>

<p>类型 natpair 只有一个构造子 pair，说明构造一对自然数的唯一方法是把pair 作用到两个自然数上。</p>
<p>下面我们定义两个投影（projection）函数，把给定的一对自然数投影到第一或第二个组成数字上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition proj1 (p : natpair) : nat :=</span><br><span class="line">match p with</span><br><span class="line">| (x,y) =&gt; x</span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line">Definition proj2 (p : natpair) : nat :=</span><br><span class="line">match p with</span><br><span class="line">| (x,y) =&gt; y</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<p>例如，下面的命令测试如何把一对数字 (1, 2) 变成 (2, 1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compute (proj2 (1, 2), proj1 (1, 2)).</span><br></pre></td></tr></table></figure>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>通过推广二元组类型，我们可以构建三元组、四元组等等，更一般情况就是列表，其长度可以变化。简单而言，由自然数组成的一个列表或者是空表，或者是由一个自然数和另一个列表组成的二元组。我们在模块 NatList 中定义自然数列表类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive natlist : Type :=</span><br><span class="line">| nil</span><br><span class="line">| cons (n : nat) (l : natlist).</span><br></pre></td></tr></table></figure>

<p>这个定义中用到两个构造子：nil 表示空表；cons 把自然数 n 和列表 l 组合成一个更长的列表 cons n l。</p>
<p>我们引入中缀操作符记号 :: 和方括号来表示列表，其中细节暂时不用关心。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition list1 := 1 :: (3 :: (5 :: nil)).</span><br><span class="line">Definition list2 := 1 :: 3 :: 5 :: nil.</span><br><span class="line">Definition list3 := [1;3;5].</span><br></pre></td></tr></table></figure>

<p>利用这些记号，我们定义 3 个列表，实际上描述的是同一个列表。</p>
<p>下面我们定义一些有用的函数，方便对列表进行操纵。函数 repeat 有两个输入参数 n 和 count，它返回一个长度为 count 的列表，其中每个元素都是 n。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint repeat (n count : nat) : natlist :=</span><br><span class="line">match count with</span><br><span class="line">| O =&gt; nil</span><br><span class="line">| S count&#x27; =&gt; n :: (repeat n count&#x27;)</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<p>函数 length 可用于计算一个列表的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint length (l:natlist) : nat :=</span><br><span class="line">match l with</span><br><span class="line">| nil =&gt; O</span><br><span class="line">| h :: t =&gt; S (length t)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Coq</category>
      </categories>
      <tags>
        <tag>coq</tag>
      </tags>
  </entry>
  <entry>
    <title>Coq Basics (II)</title>
    <url>/2023/03/28/LISTS-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88coq%EF%BC%89/</url>
    <content><![CDATA[<h2 id="数值序对"><a href="#数值序对" class="headerlink" title="数值序对"></a>数值序对</h2><p>在 Inductive 类型定义中，每个构造子（Constructor）可以有任意多个参数 —— 可以没有（如 true 和 O），可以只有一个（如 S），也可以更多 （如 nybble，以及下文所示）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive natprod : Type :=</span><br><span class="line">| pair (n1 n2 : nat).</span><br></pre></td></tr></table></figure>

<p>此声明可以读作：“构造数值序对的唯一一种方法，就是将构造子 pair 应用到两个 nat 类型的参数上。”</p>
<p>下述函数分别用于提取二元组中的第一个和第二个分量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Definition fst (p : natprod) : nat :=</span><br><span class="line">  match p with</span><br><span class="line">  | pair x y ⇒ x</span><br><span class="line">  end.</span><br><span class="line">Definition snd (p : natprod) : nat :=</span><br><span class="line">  match p with</span><br><span class="line">  | pair x y ⇒ y</span><br><span class="line">  end.</span><br><span class="line">Compute (fst (pair 3 5)).</span><br><span class="line">(* ===&gt; 3 *)</span><br></pre></td></tr></table></figure>

<p>由于二元组十分常用，不妨以标准的数学记法 (x,y) 取代 pair x y。 通过 Notation 向 Coq 声明该记法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Notation &quot;( x , y )&quot; := (pair x y).</span><br></pre></td></tr></table></figure>

<p>现在我们来证明一些有关二元组的简单事实。<br>如果我们以稍显古怪的方式陈述序对的性质，那么有时只需 reflexivity（及其内建的简化）即可完成证明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem surjective_pairing&#x27; : ∀ (n m : nat),</span><br><span class="line">  (n,m) = (fst (n,m), snd (n,m)).</span><br><span class="line">Proof.</span><br><span class="line">  reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>但是，如果我们用一种更为自然的方式来陈述此引理的话，只用 reflexivity 还不够。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem surjective_pairing_stuck : ∀ (p : natprod),</span><br><span class="line">  p = (fst p, snd p).</span><br><span class="line">Proof.</span><br><span class="line">  simpl. (* 啥也没有归约！ *)</span><br><span class="line">Abort.</span><br></pre></td></tr></table></figure>

<p>我们还需要向 Coq 展示 p 的具体结构，这样 simpl 才能对 fst 和 snd 做模式匹配。通过 destruct 可以达到这个目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem surjective_pairing : ∀ (p : natprod),</span><br><span class="line">  p = (fst p, snd p).</span><br><span class="line">Proof.</span><br><span class="line">  intros p. destruct p as [n m]. simpl. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>注意：不同于解构自然数产生两个子目标，destruct 在此只产生 一个子目标。这是因为 natprod 只有一种构造方法。</p>
<h2 id="数值列表"><a href="#数值列表" class="headerlink" title="数值列表"></a>数值列表</h2><p>通过推广序对的定义，数值’列表’类型可以这样描述： “一个列表要么是空的，要么就是由一个数和另一个列表组成的序对。”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive natlist : Type :=</span><br><span class="line">  | nil</span><br><span class="line">  | cons (n : nat) (l : natlist).</span><br></pre></td></tr></table></figure>

<p>例如，这是一个三元素列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition mylist := cons 1 (cons 2 (cons 3 nil)).</span><br></pre></td></tr></table></figure>

<p>和序对一样，使用熟悉的编程记法来表示列表会更方便些。 以下两个声明能让我们用 :: 作为中缀的 cons 操作符， 用方括号作为构造列表的“外围（outfix）”记法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">otation &quot;x :: l&quot; := (cons x l)</span><br><span class="line">                     (at level 60, right associativity).</span><br><span class="line">Notation &quot;[ ]&quot; := nil.</span><br><span class="line">Notation &quot;[ x ; .. ; y ]&quot; := (cons x .. (cons y nil) ..).</span><br></pre></td></tr></table></figure>

<p>我们不必完全理解这些声明，但如果你感兴趣的话，我会大致说明一下 发生了什么。注解 “right associativity” 告诉 Coq 当遇到多个 :: 时如何给表达式加括号，如此一来下面三个声明做的就是同一件事：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition mylist1 := 1 :: (2 :: (3 :: nil)).</span><br><span class="line">Definition mylist2 := 1 :: 2 :: 3 :: nil.</span><br><span class="line">Definition mylist3 := [1;2;3].</span><br></pre></td></tr></table></figure>

<h2 id="构造和操作列表的函数"><a href="#构造和操作列表的函数" class="headerlink" title="构造和操作列表的函数"></a>构造和操作列表的函数</h2><h3 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h3><p>第一个是 repeat 函数，它接受一个数字 n 和一个 count，返回一个长度为 count，每个元素都是 n 的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint repeat (n count : nat) : natlist :=</span><br><span class="line">  match count with</span><br><span class="line">  | O ⇒ nil</span><br><span class="line">  | S count&#x27; ⇒ n :: (repeat n count&#x27;)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<h3 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h3><p>length 函数用来计算列表的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint length (l:natlist) : nat :=</span><br><span class="line">  match l with</span><br><span class="line">  | nil ⇒ O</span><br><span class="line">  | h :: t ⇒ S (length t)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p>app 函数用来把两个列表联接起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint app (l1 l2 : natlist) : natlist :=</span><br><span class="line">  match l1 with</span><br><span class="line">  | nil ⇒ l2</span><br><span class="line">  | h :: t ⇒ h :: (app t l2)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>由于下文中随处可见，不妨将其定义为中缀运算符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Notation &quot;x ++ y&quot; := (app x y)</span><br><span class="line">                     (right associativity, at level 60).</span><br><span class="line">Example test_app1: [1;2;3] ++ [4;5] = [1;2;3;4;5].</span><br><span class="line">Proof. reflexivity. Qed.</span><br><span class="line">Example test_app2: nil ++ [4;5] = [4;5].</span><br><span class="line">Proof. reflexivity. Qed.</span><br><span class="line">Example test_app3: [1;2;3] ++ nil = [1;2;3].</span><br><span class="line">Proof. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<h3 id="Head-与-Tail"><a href="#Head-与-Tail" class="headerlink" title="Head 与 Tail"></a>Head 与 Tail</h3><p>下面介绍列表上的两种运算：hd 函数返回列表的第一个元素（即“表头”）； tl 函数返回列表除去第一个元素以外的部分（即“表尾”）。由于空表没有表头， 我们必须传入一个参数作为返回的默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition hd (default:nat) (l:natlist) : nat :=</span><br><span class="line">  match l with</span><br><span class="line">  | nil ⇒ default</span><br><span class="line">  | h :: t ⇒ h</span><br><span class="line">  end.</span><br><span class="line">Definition tl (l:natlist) : natlist :=</span><br><span class="line">  match l with</span><br><span class="line">  | nil ⇒ nil</span><br><span class="line">  | h :: t ⇒ t</span><br><span class="line">  end.</span><br><span class="line">  </span><br><span class="line">Example test_hd1: hd 0 [1;2;3] = 1.</span><br><span class="line">Proof. reflexivity. Qed.</span><br><span class="line">Example test_hd2: hd 0 [] = 0.</span><br><span class="line">Proof. reflexivity. Qed.</span><br><span class="line">Example test_tl: tl [1;2;3] = [2;3].</span><br><span class="line">Proof. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<h3 id="用列表实现口袋（Bag）"><a href="#用列表实现口袋（Bag）" class="headerlink" title="用列表实现口袋（Bag）"></a>用列表实现口袋（Bag）</h3><p>bag（或者叫 multiset 多重集）类似于集合，只是其中每个元素都能出现不止一次。 口袋的一种可行的表示是列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition bag := natlist.</span><br></pre></td></tr></table></figure>

<h2 id="有关列表的论证"><a href="#有关列表的论证" class="headerlink" title="有关列表的论证"></a>有关列表的论证</h2><p>和数字一样，有些列表处理函数的简单事实仅通过化简就能证明。 例如，对于下面这个例子，reflexivity 所做的简化就已经足够了…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem nil_app : ∀ l:natlist,</span><br><span class="line">  [] ++ l = l.</span><br><span class="line">Proof. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>…由于 [] 被替换进了 app 定义中相应的“被检”分支 （即经由匹配“仔细检查”过值的表达式），整个匹配得以被简化。<br>和数字一样，有时对一个列表做分类讨论（是否是空）是非常有用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem tl_length_pred : ∀ l:natlist,</span><br><span class="line">  pred (length l) = length (tl l).</span><br><span class="line">Proof.</span><br><span class="line">  intros l. destruct l as [| n l&#x27;].</span><br><span class="line">  - (* l = nil *)</span><br><span class="line">    reflexivity.</span><br><span class="line">  - (* l = cons n l&#x27; *)</span><br><span class="line">    reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>在这里 nil 的情况能够工作是因为我们定义了 tl nil &#x3D; nil， 而 destruct 策略中 as 注解引入的两个名字，n 和 l’，分别对应了 cons 构造子的两个参数（正在构造的列表的头和尾）。<br>然而一般来说，许多关于列表的有趣定理都需要用到归纳法来证明， 接下来我们就会看到证明的方法。</p>
<h2 id="对列表进行归纳"><a href="#对列表进行归纳" class="headerlink" title="对列表进行归纳"></a>对列表进行归纳</h2><p>比起对自然数的归纳，读者可能对归纳证明 natlist 这样的数据类型更加陌生。 不过基本思路同样简单。每个 Inductive 声明定义了一组数据值， 这些值可以用声明过的构造子来构造。</p>
<p>例如，布尔值可以用 true 或 false 来构造； 自然数可以用 O 或 S 应用到另一个自然数上来构造；而列表可以用 nil 或者将 cons 应用到一个自然数和另一个列表上来构造。 除此以外，归纳定义的集合中元素的形式 ‘只能是’ 构造子对其它项的应用。</p>
<p>这一事实同时也给出了一种对归纳定义的集合进行论证的方法：一个自然数要么是 O，要么就是 S 应用到某个’更小’的自然数上；一个列表要么是 nil， 要么就是 cons 应用到某个数字和某个’更小’的列表上，诸如此类。 所以，如果我们有某个命题 P 涉及列表 l，而我们想证明 P 对 ‘一切’ 列表都成立，那么可以像这样推理：</p>
<p>1.首先，证明当 l 为 nil 时 P l 成立。<br>2.然后，证明当 l 为 cons n l’ 时 P l 成立，其中 n 是某个自然数，l’ 是某个更小的列表，假设 P l’ 成立.<br>3.由于较大的列表总是能够分解为较小的列表，最终这个较小的列表会变成 nil，这两点合在一起就完成了 P 对一切列表 l 成立的证明。</p>
<p>下面是个具体的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theorem app_assoc : ∀ l1 l2 l3 : natlist,</span><br><span class="line">  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).</span><br><span class="line">Proof.</span><br><span class="line">  intros l1 l2 l3. induction l1 as [| n l1&#x27; IHl1&#x27;].</span><br><span class="line">  - (* l1 = nil *)</span><br><span class="line">    reflexivity.</span><br><span class="line">  - (* l1 = cons n l1&#x27; *)</span><br><span class="line">    simpl. rewrite → IHl1&#x27;. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>注意，和归纳自然数时一样，此处 induction 策略的 as… 从句为在 “l1 由构造子 cons 构造而来”这一情况时出现的“更小的列表”和归纳假设取了名字。</p>
<h2 id="反转列表"><a href="#反转列表" class="headerlink" title="反转列表"></a>反转列表</h2><p>举一个更加深入的例子来说明对列表的归纳证明：假设我们使用 app 来定义一个列表反转函数 rev：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint rev (l:natlist) : natlist :=</span><br><span class="line">  match l with</span><br><span class="line">  | nil ⇒ nil</span><br><span class="line">  | h :: t ⇒ rev t ++ [h]</span><br><span class="line">  end.</span><br><span class="line">Example test_rev1: rev [1;2;3] = [3;2;1].</span><br><span class="line">Proof. reflexivity. Qed.</span><br><span class="line">Example test_rev2: rev nil = nil.</span><br><span class="line">Proof. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>为了比目前所见的证明多一点挑战性， 我们来证明反转一个列表不会改变它的长度。 我们的首次尝试在后继这一分支上卡住了….</p>
<h2 id="Search-搜索"><a href="#Search-搜索" class="headerlink" title="Search 搜索"></a>Search 搜索</h2><p>我们已经见过很多需要使用之前证明过的结论（例如通过 rewrite）来证明的定理了。 但是在引用别的定理时，我们必须事先知道它们的名字。当然，即使是已被证明的定理本身 我们都不能全部记住，更不用提它们的名字了。<br>Coq 的 Search 指令在这时就非常有用了。执行 Search foo 会让 Coq 显示所有涉及到 foo 的定理。例如，去掉下面的注释后， 你会看到一个我们证明过的所有关于 rev 的定理的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(*  Search rev. *)</span><br></pre></td></tr></table></figure>

<p>在接下来的学习中，你要记得使用 Search，它能为你节约大量的时间！</p>
<h2 id="偏映射（Partial-Maps）"><a href="#偏映射（Partial-Maps）" class="headerlink" title="偏映射（Partial Maps）"></a>偏映射（Partial Maps）</h2><p>最后演示一下如何在 Coq 中定义基础的数据结构。这是一个简单的 ‘偏映射’ 数据类型，它类似于大多数编程语言中的映射或字典数据结构。<br>首先，我们定义一个新的归纳数据类型 id 来用作偏映射的“键”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive id : Type :=</span><br><span class="line">  | Id (n : nat).</span><br></pre></td></tr></table></figure>

<p>本质上来说，id 只是一个数。但通过 Id 标签封装自然数来引入新的类型， 能让定义变得更加可读，同时也给了我们更多的灵活性。<br>我们还需要一个 id 的相等关系测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition eqb_id (x1 x2 : id) :=</span><br><span class="line">  match x1, x2 with</span><br><span class="line">  | Id n1, Id n2 ⇒ n1 =? n2</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>现在我们定义偏映射的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Module PartialMap.</span><br><span class="line">Export NatList.</span><br><span class="line">Inductive partial_map : Type :=</span><br><span class="line">  | empty</span><br><span class="line">  | record (i : id) (v : nat) (m : partial_map).</span><br></pre></td></tr></table></figure>

<p>此声明可以读作：“有两种方式可以构造一个 partial_map：用构造子 empty 表示一个空的偏映射，或将构造子 record 应用到一个键、一个值和一个既有的 partial_map 来构造一个带“键-值”映射 的 partial_map。”</p>
<p>update 函数在部分映射中覆盖给定的键以取缔原值（如该键尚不存在， 则新建其记录）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition update (d : partial_map)</span><br><span class="line">                                   (x : id) (value : nat)</span><br><span class="line">                                   : partial_map :=</span><br><span class="line">  record x value d.</span><br></pre></td></tr></table></figure>

<p>最后，find 函数按照给定的键搜索一个 partial_map。若该键无法找到， 它就返回 None；若该键与 val 相关联，则返回 Some val。 若同一个键被映到多个值，find 就会返回它遇到的第一个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint find (x : id) (d : partial_map) : natoption :=</span><br><span class="line">  match d with</span><br><span class="line">  | empty ⇒ None</span><br><span class="line">  | record y v d&#x27; ⇒ if eqb_id x y</span><br><span class="line">                     then Some v</span><br><span class="line">                     else find x d&#x27;</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Coq</category>
      </categories>
      <tags>
        <tag>coq</tag>
      </tags>
  </entry>
  <entry>
    <title>Coq Basics (III)</title>
    <url>/2023/04/24/%E5%A4%9A%E6%80%81%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="多态列表"><a href="#多态列表" class="headerlink" title="多态列表"></a>多态列表</h2><p>有趣的程序还需要能够处理其它元素类型的列表，如字符串列表、布尔值列表、 列表的列表等等。我们’可以’分别为它们定义新的归纳数据类型，例如…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive boollist : Type :=</span><br><span class="line">  | bool_nil</span><br><span class="line">  | bool_cons (b : bool) (l : boollist).</span><br></pre></td></tr></table></figure>

<p>…不过这样很快就会变得乏味。 部分原因在于我们必须为每种数据类型都定义不同的构造子， 然而主因还是我们必须为每种数据类型再重新定义一遍所有的列表处理函数 （ length、rev 等）以及它们所有的性质（rev_length、app_assoc 等）。<br>为避免这些重复，Coq 支持定义’多态’归纳类型。 例如，以下就是’多态列表’数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive list (X:Type) : Type :=</span><br><span class="line">  | nil</span><br><span class="line">  | cons (x : X) (l : list X).</span><br></pre></td></tr></table></figure>

<p>这和上一章中 natlist 的定义基本一样，只是将 cons 构造子的 nat 参数换成了任意的类型 X，函数头的第一行添加了 X 的绑定， 而构造子类型中的 natlist 则换成了 list X。（我们可以重用构造子名 nil 和 cons，因为之前定义的 natlist 在当前作用之外的一个 Module 中。）</p>
<p>list 本身又是什么类型？一种不错的思路就是把 list 当做从 Type 类型到 Inductive 归纳定义的’函数’；或者换种更简明的思路，即 list 是个从 Type 类型到 Type 类型的函数。对于任何特定的类型 X， 类型 list X 是一个 Inductive 归纳定义的，元素类型为 X 的列表的集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check list : Type → Type.</span><br></pre></td></tr></table></figure>

<p>list 的定义中的参数 X 自动 成为构造子 nil 和 cons 的参数 —— 也就是说，nil 和 cons 在这里是多态 的构造子；现在我们调用它们的时候必须要提供一个参数，就是它们要构造的列表的具 体类型。例如，nil nat 构造的是 nat 类型的空列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check (nil nat) : list nat.</span><br></pre></td></tr></table></figure>

<p>cons nat 与此类似，它将类型为 nat 的元素添加到类型为 list nat 的列表中。以下示例构造了一个只包含自然数 3 的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check (cons nat 3 (nil nat)) : list nat.</span><br></pre></td></tr></table></figure>

<p>nil 的类型会是什么呢？也许我们可以（根据定义）说它是 list X， 不过这样它就不是接受 X 返回 list 的函数了。再提出一种：Type → list X 并没有解释 X 是什么，(X : Type) → list X 则比较接近。 Coq 对这种情况的记法为 ∀ X : Type, list X：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check nil : ∀ X : Type, list X.</span><br></pre></td></tr></table></figure>

<p>类似地，定义中 cons 的类型看起来像 X → list X → list X 然而以上述约定来解释 X 的含义则可以得到类型 ∀ X, X → list X → list X。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check cons : ∀ X : Type, X → list X → list X.</span><br></pre></td></tr></table></figure>

<p>（关于记法的附注：在 .v 文件中，量词“forall”会写成字母的形式， 而在生成的 HTML 和一些设置了显示控制的 IDE 中，∀ 通常会渲染成一般的“倒 A”数学符号，虽然你偶尔还是会看到英文拼写的 “forall”。这只是排版上的效果，它们的含义没有任何区别。）</p>
<p>如果在每次使用列表构造子时，都要为它提供类型参数，那样会很麻烦。 不过我们很快就会看到如何省去这种麻烦。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check (cons nat 2 (cons nat 1 (nil nat)))</span><br><span class="line">      : list nat.</span><br></pre></td></tr></table></figure>

<p>现在我们可以回过头来定义之前写下的列表处理函数的多态版本了。 例如 repeat：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=</span><br><span class="line">  match count with</span><br><span class="line">  | 0 ⇒ nil X</span><br><span class="line">  | S count&#x27; ⇒ cons X x (repeat X x count&#x27;)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>同 nil 与 cons 一样，我们可以通过将 repeat 应用到一个类型、一个该类型的元素以及一个数字来使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example test_repeat1 :</span><br><span class="line">  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).</span><br><span class="line">Proof. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<p>要用 repeat 构造其它种类的列表， 我们只需通过对应类型的参数将它实例化即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example test_repeat2 :</span><br><span class="line">  repeat bool false 1 = cons bool false (nil bool).</span><br><span class="line">Proof. reflexivity. Qed.</span><br></pre></td></tr></table></figure>

<h2 id="类型标注的推断"><a href="#类型标注的推断" class="headerlink" title="类型标注的推断"></a>类型标注的推断</h2><p>我们再写一遍 repeat 的定义，不过这次不指定任何参数的类型。 Coq 还会接受它么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint repeat&#x27; X x count : list X :=</span><br><span class="line">  match count with</span><br><span class="line">  | 0 ⇒ nil X</span><br><span class="line">  | S count&#x27; ⇒ cons X x (repeat&#x27; X x count&#x27;)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>确实会。我们来看看 Coq 赋予了 repeat’ 什么类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check repeat&#x27;</span><br><span class="line">  : ∀ X : Type, X → nat → list X.</span><br><span class="line">Check repeat</span><br><span class="line">  : ∀ X : Type, X → nat → list X.</span><br></pre></td></tr></table></figure>

<p>它与 repeat 的类型完全一致。Coq 可以使用’类型推断’ 基于它们的使用方式来推出 X、x 和 count 一定是什么类型。例如， 由于 X 是作为 cons 的参数使用的，因此它必定是个 Type 类型， 因为 cons 期望一个 Type 作为其第一个参数，而用 0 和 S 来匹配 count 意味着它必须是个 nat，诸如此类。</p>
<p>这种强大的功能意味着我们不必总是在任何地方都显式地写出类型标注， 不过显式的类型标注对于文档和完整性检查来说仍然非常有用， 因此我们仍会继续使用它。在代码中使用类型标注时，你应当把握好一个度， 太多会导致混乱并分散注意力，太少则会迫使读者为理解你的代码而在大脑中进行类型推断。</p>
<h2 id="类型参数的推断"><a href="#类型参数的推断" class="headerlink" title="类型参数的推断"></a>类型参数的推断</h2><p>要使用多态函数，我们需要为其参数再额外传入一个或更多类型。 例如，前面 repeat 函数体中的递归调用必须传递类型 X。不过由于 repeat 的第二个参数为 X 类型的元素，第一个参数明显只能是 X， 既然如此，我们何必显式地写出它呢？</p>
<p>幸运的是，Coq 允许我们避免这种冗余。在任何我们可以写类型参数的地方，我们都可 以将类型参数写为 “洞” _，可以看做是说 “请 Coq 自行找出这里应该填什么。” 更确切地说，当 Coq 遇到 _ 时，它会尝试’统一’所有的局部变量信息， 包括函数应当应用到的类型，其它参数的类型，以及应用函数的上下文中期望的类型， 以此来确定 _ 处应当填入的具体类型。</p>
<p>这听起来很像类型标注推断。实际上，这两种个过程依赖于同样的底层机制。 除了简单地忽略函数中某些参数的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat&#x27; X x count : list X :=</span><br></pre></td></tr></table></figure>

<p>我们还可以将类型换成‘ _ ’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat&#x27; (X : _) (x : _) (count : _) : list X :=</span><br></pre></td></tr></table></figure>

<p>以此来告诉 Coq 要尝试推断出缺少的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint repeat&#x27;&#x27; X x count : list X :=</span><br><span class="line">  match count with</span><br><span class="line">  | 0 ⇒ nil _</span><br><span class="line">  | S count&#x27; ⇒ cons _ x (repeat&#x27;&#x27; _ x count&#x27;)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>在此例中，我们写出 _ 并没有省略多少 X。然而在很多情况下， 这对提高可读性还是很有效的。例如，假设我们要写下一个包含数字 1、2 和 3 的列表，此时不必写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition list123 :=</span><br><span class="line">  cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).</span><br></pre></td></tr></table></figure>

<p>……我们可以用洞来这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition list123&#x27; :=</span><br><span class="line">  cons _ 1 (cons _ 2 (cons _ 3 (nil _))).</span><br></pre></td></tr></table></figure>

<h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><p>我们甚至可以通过告诉 Coq ‘总是’推断给定函数的类型参数来在大多数情况下 直接避免写 _。</p>
<p>Arguments 用于指令指定函数或构造子的名字并列出其参数名， 花括号中的任何参数都会被视作隐式参数。（如果定义中的某个参数没有名字， 那么它可以用通配模式 _ 来标记。这种情况常见于构造子中。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arguments nil &#123;X&#125;.</span><br><span class="line">Arguments cons &#123;X&#125; _ _.</span><br><span class="line">Arguments repeat &#123;X&#125; x count.</span><br></pre></td></tr></table></figure>

<p>现在我们完全不用提供类型参数了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition list123&#x27;&#x27; := cons 1 (cons 2 (cons 3 nil)).</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以在定义函数时就声明隐式参数， 只需要将某个参数两边的圆括号换成花括号。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint repeat&#x27;&#x27;&#x27; &#123;X : Type&#125; (x : X) (count : nat) : list X :=</span><br><span class="line">  match count with</span><br><span class="line">  | 0 ⇒ nil</span><br><span class="line">  | S count&#x27; ⇒ cons x (repeat&#x27;&#x27;&#x27; x count&#x27;)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>（注意我们现在甚至不必在 repeat’’’ 的递归调用中提供类型参数了， 实际上提供了反而是无效的，因为 Coq 并不想要它。）<br>我们会尽可能使用最后一种风格，不过还会继续在 Inductive 构造子中使用显式的 Argument 声明。原因在于如果将归纳类型的形参标为隐式的话， 不仅构造子的类型会变成隐式的，类型本身也会变成隐式的。例如， 考虑以下 list 类型的另一种定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive list&#x27; &#123;X:Type&#125; : Type :=</span><br><span class="line">  | nil&#x27;</span><br><span class="line">  | cons&#x27; (x : X) (l : list&#x27;).</span><br></pre></td></tr></table></figure>

<p>由于 X 在包括 list’ 本身的’整个’归纳定义中都是隐式声明的， 因此当我们讨论数值、布尔值或其它任何类型的列表时，都只能写 list’， 而写不了 list’ nat、list’ bool 等等，这样就有点过分了。</p>
<h2 id="显式提供类型参数"><a href="#显式提供类型参数" class="headerlink" title="显式提供类型参数"></a>显式提供类型参数</h2><p>用 Implicit 将参数声明为隐式的会有个小问题：Coq 偶尔会没有足够的局部信息来确定类型参数。此时，我们需要告诉 Coq 这次我们会显示地给出参数。例如，假设我们写了如下定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fail Definition mynil := nil.</span><br></pre></td></tr></table></figure>

<p>（Definition 前面的 Fail 限定符可用于’任何’指令， 它的作用是确保该指令在执行时确实会失败。如果该指令失败了，Coq 就会打印出相应的错误信息，不过之后会继续处理文件中剩下的部分。）<br>在这里，Coq 给出了一条错误信息，因为它不知道应该为 nil 提供何种类型。 我们可以为它提供个显式的类型声明来帮助它，这样 Coq 在“应用”nil 时就有更多可用的信息了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition mynil : list nat := nil.</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以在函数名前加上前缀 @ 来强制将隐式参数变成显式的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check @nil : ∀ X : Type, list X.</span><br><span class="line">Definition mynil&#x27; := @nil nat.</span><br></pre></td></tr></table></figure>

<p>使用参数推断和隐式参数，我们可以为列表定义和前面一样的简便记法。 由于我们让构造子的的类型参数变成了隐式的，因此 Coq 就知道在我们使用该记法时自动推断它们了。</p>
<h2 id="多态序对"><a href="#多态序对" class="headerlink" title="多态序对"></a>多态序对</h2><p>按照相同的模式，我们在上一章中给出的数值序对的定义可被推广为 ‘多态序对（Polymorphic Pairs）’，它通常叫做’积（Products）’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inductive prod (X Y : Type) : Type :=</span><br><span class="line">| pair (x : X) (y : Y).</span><br><span class="line">Arguments pair &#123;X&#125; &#123;Y&#125; _ _.</span><br></pre></td></tr></table></figure>

<p>和列表一样，我们也可以将类型参数定义成隐式的， 并以此定义类似的具体记法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Notation &quot;( x , y )&quot; := (pair x y).</span><br></pre></td></tr></table></figure>

<p>我们也可以使用 Notation 来定义标准的’积类型（Product Types）’记法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Notation &quot;X * Y&quot; := (prod X Y) : type_scope.</span><br></pre></td></tr></table></figure>

<p>（标注 : type_scope 会告诉 Coq 该缩写只能在解析类型而非表达式时使用。 这避免了与乘法符号的冲突。)</p>
<p>一开始会很容易混淆 (x,y) 和 X×Y。不过要记住 (x,y) 是一个’值’，它由两个其它的值构造得来；而 X×Y 是一个’类型’， 它由两个其它的类型构造得来。如果 x 的类型为 X 而 y 的类型为 Y， 那么 (x,y) 的类型就是 X×Y。</p>
<p>第一元（first）和第二元（second）的射影函数（Projection Functions） 现在看起来和其它函数式编程语言中的很像了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition fst &#123;X Y : Type&#125; (p : X × Y) : X :=</span><br><span class="line">  match p with</span><br><span class="line">  | (x, y) ⇒ x</span><br><span class="line">  end.</span><br><span class="line">  </span><br><span class="line">Definition snd &#123;X Y : Type&#125; (p : X × Y) : Y :=</span><br><span class="line">  match p with</span><br><span class="line">  | (x, y) ⇒ y</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>以下函数接受两个列表，并将它们结合成一个序对的列表。 在其它函数式语言中，它通常被称作 zip。我们为了与 Coq 的标准库保持一致， 将它命名为 combine。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint combine &#123;X Y : Type&#125; (lx : list X) (ly : list Y)</span><br><span class="line">           : list (X×Y) :=</span><br><span class="line">  match lx, ly with</span><br><span class="line">  | [], _ ⇒ []</span><br><span class="line">  | _, [] ⇒ []</span><br><span class="line">  | x :: tx, y :: ty ⇒ (x, y) :: (combine tx ty)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<h2 id="多态候选"><a href="#多态候选" class="headerlink" title="多态候选"></a>多态候选</h2><p>最后一种要介绍的多态类型是’多态候选（Polymorphic Options）’, 它推广了上一章中的 natoption（由于我们之后要用标准库中定义的 option 版本，因此这里的定义我们把它放在模块中）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Module OptionPlayground.</span><br><span class="line">Inductive option (X:Type) : Type :=</span><br><span class="line">  | Some (x : X)</span><br><span class="line">  | None.</span><br><span class="line">Arguments Some &#123;X&#125; _.</span><br><span class="line">Arguments None &#123;X&#125;.</span><br><span class="line">End OptionPlayground.</span><br></pre></td></tr></table></figure>

<p>现在我们可以重写 nth_error 函数来让它适用于任何类型的列表了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint nth_error &#123;X : Type&#125; (l : list X) (n : nat)</span><br><span class="line">                   : option X :=</span><br><span class="line">  match l with</span><br><span class="line">  | [] ⇒ None</span><br><span class="line">  | a :: l&#x27; ⇒ if n =? O then Some a else nth_error l&#x27; (pred n)</span><br><span class="line">  end.</span><br><span class="line">Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.</span><br><span class="line">Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].</span><br><span class="line">Example test_nth_error3 : nth_error [true] 2 = None.</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>用于操作其它函数的函数通常叫做’高阶函数’。以下是简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition doit3times &#123;X:Type&#125; (f:X→X) (n:X) : X :=</span><br><span class="line">  f (f (f n)).</span><br></pre></td></tr></table></figure>

<p>这里的参数 f 本身也是个（从 X 到 X 的）函数， doit3times 的函数体将 f 对某个值 n 应用三次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check @doit3times : ∀ X : Type, (X → X) → X → X.</span><br><span class="line">Example test_doit3times: doit3times minustwo 9 = 3.</span><br><span class="line">Example test_doit3times&#x27;: doit3times negb true = false.</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>下面是个更有用的高阶函数，它接受一个元素类型为 X 的列表和一个 X 的谓词（即一个从 X 到 bool 的函数），然后“过滤”此列表并返回一个新列表， 其中仅包含对该谓词返回 true 的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint filter &#123;X:Type&#125; (test: X→bool) (l:list X)</span><br><span class="line">                : (list X) :=</span><br><span class="line">  match l with</span><br><span class="line">  | [] ⇒ []</span><br><span class="line">  | h :: t ⇒ if test h then h :: (filter test t)</span><br><span class="line">                        else filter test t</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>例如，如果我们将 filter 应用到谓词 evenb 和一个数值列表 l 上，那么它就会返回一个只包含 l 中偶数的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example test_filter1: filter evenb [1;2;3;4] = [2;4].</span><br><span class="line"></span><br><span class="line">Definition length_is_1 &#123;X : Type&#125; (l : list X) : bool :=</span><br><span class="line">  (length l) =? 1.</span><br><span class="line">Example test_filter2:</span><br><span class="line">    filter length_is_1</span><br><span class="line">           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]</span><br><span class="line">  = [ [3]; [4]; [8] ].</span><br></pre></td></tr></table></figure>

<p>我们可以使用 filter 给出 Lists 中 count odd members 函数的简洁的版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition countoddmembers&#x27; (l:list nat) : nat :=</span><br><span class="line">  length (filter oddb l).</span><br><span class="line">Example test_countoddmembers&#x27;1: countoddmembers&#x27; [1;0;3;1;4;5] = 4.</span><br><span class="line">Example test_countoddmembers&#x27;2: countoddmembers&#x27; [0;2;4] = 0.</span><br><span class="line">Example test_countoddmembers&#x27;3: countoddmembers&#x27; nil = 0.</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>在上面这个例子中，我们不得不定义一个名为 length_is_1 的函数， 以便让它能够作为参数传入到 filter 中，由于该函数可能再也用不到了， 这有点令人沮丧。我们经常需要传入“一次性”的函数作为参数，之后不会再用， 而为每个函数取名是十分无聊的。<br>幸运的是，有一种更好的方法。我们可以按需随时构造函数而不必在顶层中声明它 或给它取名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example test_anon_fun&#x27;:</span><br><span class="line">  doit3times (fun n ⇒ n × n) 2 = 256.</span><br></pre></td></tr></table></figure>

<p>表达式 (fun n ⇒ n × n) 可读作“一个给定 n 并返回 n × n 的函数。”<br>以下为使用匿名函数重写的 filter 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example test_filter2&#x27;:</span><br><span class="line">    filter (fun l ⇒ (length l) =? 1)</span><br><span class="line">           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]</span><br><span class="line">  = [ [3]; [4]; [8] ].</span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>另一个方便的高阶函数叫做 map。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint map &#123;X Y: Type&#125; (f:X→Y) (l:list X) : (list Y) :=</span><br><span class="line">  match l with</span><br><span class="line">  | [] ⇒ []</span><br><span class="line">  | h :: t ⇒ (f h) :: (map f t)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>它接受一个函数 f 和一个列表 l &#x3D; [n1, n2, n3, …] 并返回列表 [f n1, f n2, f n3,…] ，其中 f 可分别应用于 l 中的每一个元素。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example test_map1: map (fun x ⇒ plus 3 x) [2;0;2] = [5;3;5].</span><br></pre></td></tr></table></figure>

<p>输入列表和输出列表的元素类型不必相同，因为 map 会接受’两个’类型参数 X 和 Y，因此它可以应用到一个数值的列表和一个从数值到布尔值的函数， 并产生一个布尔值列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example test_map2:</span><br><span class="line">  map oddb [2;1;2;5] = [false;true;false;true].</span><br></pre></td></tr></table></figure>

<p>它甚至可以应用到一个数值的列表和一个从数值到布尔值列表的函数， 并产生一个布尔值的’列表的列表’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example test_map3:</span><br><span class="line">    map (fun n ⇒ [evenb n;oddb n]) [2;1;2;5]</span><br><span class="line">  = [[true;false];[false;true];[true;false];[false;true]].</span><br></pre></td></tr></table></figure>

<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p>一个更加强大的高阶函数叫做 fold。本函数启发自“reduce 归约” 操作，它是 Google 的 map&#x2F;reduce 分布式编程框架的核心。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fixpoint fold &#123;X Y: Type&#125; (f: X→Y→Y) (l: list X) (b: Y)</span><br><span class="line">                         : Y :=</span><br><span class="line">  match l with</span><br><span class="line">  | nil ⇒ b</span><br><span class="line">  | h :: t ⇒ f h (fold f t b)</span><br><span class="line">  end.</span><br></pre></td></tr></table></figure>

<p>直观上来说，fold 操作的行为就是将给定的二元操作符 f 插入到给定列表的每一对元素之间。例如， fold plus [1;2;3;4] 直观上的意思是 1+2+3+4。为了让它更精确，我们还需要一个“起始元素” 作为 f 初始的第二个输入。因此，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fold plus [1;2;3;4] 0</span><br></pre></td></tr></table></figure>

<p>就会产生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 + (2 + (3 + (4 + 0))).</span><br></pre></td></tr></table></figure>

<h2 id="用函数构造函数"><a href="#用函数构造函数" class="headerlink" title="用函数构造函数"></a>用函数构造函数</h2><p>目前我们讨论过的大部分高阶函数都是接受函数作为参数的。 现在我们来看一些将函数作为其它函数的结果’返回’的例子。 首先，下面是一个接受值 x（由某个类型 X 刻画）并返回一个从 nat 到 X 的函数，当它被调用时总是产生 x 并忽略其 nat 参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition constfun &#123;X: Type&#125; (x: X) : nat→X :=</span><br><span class="line">  fun (k:nat) ⇒ x.</span><br><span class="line">Definition ftrue := constfun true.</span><br><span class="line">Example constfun_example1 : ftrue 0 = true.</span><br><span class="line">Example constfun_example2 : (constfun 5) 99 = 5.</span><br></pre></td></tr></table></figure>

<p>实际上，我们已经见过的多参函数也是讲函数作为数据传入的例子。 为了理解为什么，请回想 plus 的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Check plus : nat → nat → nat.</span><br></pre></td></tr></table></figure>

<p>该表达式中的每个 → 实际上都是一个类型上的’二元’操作符。 该操作符是’右结合’的，因此 plus 的类型其实是 nat → (nat → nat) 的简写，即，它可以读作“plus 是一个单参数函数，它接受一个 nat 并返回另一个函数，该函数接受另一个 nat 并返回一个 nat”。 在上面的例子中，我们总是将 plus 一次同时应用到两个参数上。 不过如果我们喜欢，也可以一次只提供一个参数，这叫做’偏应用（Partial Application）’。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Definition plus3 := plus 3.</span><br><span class="line">Check plus3 : nat → nat.</span><br><span class="line">Example test_plus3 : plus3 4 = 7.</span><br><span class="line">Example test_plus3&#x27; : doit3times plus3 0 = 9.</span><br><span class="line">Example test_plus3&#x27;&#x27; : doit3times (plus 3) 0 = 9.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Coq</category>
      </categories>
      <tags>
        <tag>coq</tag>
      </tags>
  </entry>
</search>
